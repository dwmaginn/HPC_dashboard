Understood. I will produce a complete, executable XML plan based on the deployment PDF, using best-in-class and long-term sustainable approaches. This includes the build-step JSON generation method, staging and production environments, and an English-only interface.

I’ll return the full XML Execution Plan shortly.


<Plan>
  <WorkBreakdown>
    <Phase id="1" name="Project Initiation and Setup">
      <Batch id="1.1" name="Project Initiation">
        <Step id="1.1.1">
          <Task>Confirm project requirements and architecture</Task>
          <OwnerRoles>
            <Role>Project Manager</Role>
            <Role>Technical Lead</Role>
          </OwnerRoles>
          <Commands>
            <Command>Review the "Cannabis Product Ordering Dashboard Deployment" plan document with stakeholders to ensure all requirements (frontend, data, backend, deployment) are understood and agreed upon.</Command>
            <Command>Conduct a kickoff meeting to clarify project objectives, team member roles, and technology stack choices (HTML/CSS/JS, Node.js, PHP, etc.).</Command>
            <Command>Obtain formal sign-off from the business owner on the project plan, including acceptance of using IONOS Deploy Now and the defined data workflow.</Command>
          </Commands>
          <Verification>Meeting minutes are circulated with documented decisions, and a sign-off email or document from the business owner confirms agreement on requirements and architecture.</Verification>
          <RollBack>If any requirement is disputed or missed, reconvene with stakeholders to address concerns and update the plan before proceeding. Do not move forward until all parties approve the clarified requirements.</RollBack>
        </Step>
        <Step id="1.1.2">
          <Task>Prepare project accounts and resources</Task>
          <OwnerRoles>
            <Role>Project Manager</Role>
            <Role>DevOps Engineer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Create or verify access to an IONOS Deploy Now account with a plan supporting at least one PHP project and staging deployments.</Command>
            <Command>Ensure a custom domain name is available for the dashboard (e.g., acquire orders.examplecannabis.com or confirm existing ownership).</Command>
            <Command>Determine the SMTP email account or service for order emails (e.g., create an orders@examplecannabis.com mailbox or choose a third-party SMTP service) and obtain its credentials (SMTP host, port, username, password).</Command>
            <Command>Inform team members of credentials and access details securely (e.g., share via a password manager or encrypted channel).</Command>
          </Commands>
          <Verification>IONOS account is accessible; the custom domain is registered (or identified) and under control; SMTP account credentials have been tested (e.g., by logging into the email or sending a test email via an email client) and are valid.</Verification>
          <RollBack>If any resource is not ready (e.g., domain registration issues or SMTP account setup fails), pause development tasks and resolve the account setup (contact domain registrar support or use a temporary email service for testing). Only proceed once all necessary accounts are correctly configured.</RollBack>
        </Step>
      </Batch>
      <Batch id="1.2" name="Repository Setup">
        <Step id="1.2.1">
          <Task>Initialize GitHub repository and project structure</Task>
          <OwnerRoles>
            <Role>DevOps Engineer</Role>
            <Role>Front-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Create a new private GitHub repository (e.g., cannabis-order-dashboard) to host the project code and data. Initialize it with a README and appropriate .gitignore (include Node.js, PHP, and OS artifacts like node_modules/, vendor/, .env).</Command>
            <Command>Organize the repository structure: create directories for key components, e.g., /data (for LiveMenu.xlsx and output JSON), /assets (for compiled CSS or images). Place PHP scripts at the root or in a php/ directory (for simplicity in deployment).</Command>
            <Command>Add placeholder files: an empty LiveMenu.xlsx in /data; a basic index.html with a title and structural HTML; an empty orderSubmit.php file for the form handler; and stub JavaScript/CSS files (if needed) linked in the HTML.</Command>
            <Command>Commit and push this initial structure to the GitHub repository as the initial commit on the main branch.</Command>
          </Commands>
          <Verification>The GitHub repository is accessible online with the specified structure. Verify that LiveMenu.xlsx exists in /data, core files are present (index.html, orderSubmit.php), and no unnecessary files are committed (check that node_modules/ and other ignored files are indeed absent).</Verification>
          <RollBack>If the repository name or settings are incorrect (e.g., public instead of private), adjust repository settings or recreate the repository with correct settings. If the initial commit has structural errors, fix the directory or file issues locally and push a corrected commit before proceeding.</RollBack>
        </Step>
        <Step id="1.2.2">
          <Task>Set up local development environment</Task>
          <OwnerRoles>
            <Role>Front-End Developer</Role>
            <Role>Back-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Install Node.js (Latest LTS version) on development machines to support build tooling (Tailwind CSS and SheetJS conversion). Verify by running node --version and npm --version.</Command>
            <Command>Install PHP (version 8.x) on development machines or ensure access to a PHP runtime for local testing of the form handler. Verify by running php -v. If using a local LAMP/WAMP stack, ensure it's running and accessible.</Command>
            <Command>Clone the GitHub repository to the local machine. Confirm the file structure is present locally. Run a simple local web server for static files (e.g., using npx serve or php -S localhost:8000 from the project directory) to verify that index.html loads in a browser.</Command>
            <Command>Configure Git on local machines with correct user information. Create a development branch (e.g., dev) from main in Git for staging changes, and push this branch to GitHub (this branch will be used for staging deployments).</Command>
          </Commands>
          <Verification>Node.js and PHP respond with version info, confirming installations. The repository files are present locally. Accessing index.html via a local server displays the placeholder page. The dev branch is visible on GitHub, indicating branching strategy is in place.</Verification>
          <RollBack>If Node.js or PHP installation fails, use an alternative method (e.g., installer or package manager) to set them up. If the repository clone or branch push fails (e.g., due to permissions), check GitHub access tokens/SSH keys and retry. In case of environment issues, resolve them (or use containerized dev environments) before continuing development.</RollBack>
        </Step>
      </Batch>
    </Phase>
    <Phase id="2" name="Development">
      <Batch id="2.1" name="Data Integration and Conversion">
        <Step id="2.1.1">
          <Task>Add LiveMenu.xlsx data source</Task>
          <OwnerRoles>
            <Role>Back-End Developer</Role>
            <Role>Content Manager</Role>
          </OwnerRoles>
          <Commands>
            <Command>Populate data/LiveMenu.xlsx with initial menu content (e.g., product names, descriptions, prices, categories) as provided by the business. Use clear column headers and consistent data types for easy parsing (e.g., "Product", "Description", "Price", "Category").</Command>
            <Command>Ensure the Excel file is saved in .xlsx format and commit the initial version of LiveMenu.xlsx to the repository (on the dev branch if using a staging workflow).</Command>
          </Commands>
          <Verification>The Excel file is present in the repository and can be opened to reveal structured product data. On GitHub, verify the file appears under /data. The data is formatted in tabular form with correct headers (no missing columns) per requirements.</Verification>
          <RollBack>If the Excel file contains errors or is formatted incorrectly (e.g., missing headers, typos), correct the file in Excel and recommit. If commit history has a large or wrong file, consider rewriting history to remove it (to avoid large files) and recommit a correct version. If the Excel file is too large or causing performance issues, ensure unnecessary formatting or images are removed.</RollBack>
        </Step>
        <Step id="2.1.2">
          <Task>Implement Excel-to-JSON conversion script</Task>
          <OwnerRoles>
            <Role>Back-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Install the SheetJS xlsx package as a project dependency by running npm install xlsx --save in the repository root (this creates/updates package.json and package-lock.json).</Command>
            <Command>Create a Node.js script (e.g., convertMenu.js in the project root or a scripts/ directory) that reads data/LiveMenu.xlsx and outputs a JSON file. Use the SheetJS library: for example, read the file with XLSX.readFile('data/LiveMenu.xlsx'), then use XLSX.utils.sheet_to_json on the first sheet to get an array of objects.</Command>
            <Command>Format the JSON output as needed for the frontend (e.g., an array of products with fields matching the Excel columns). Write the JSON data to data/menu.json (or assets/menu.json if that folder is web-accessible) within the repository.</Command>
            <Command>Test the script locally by running node convertMenu.js. Confirm it executes without errors and that menu.json is created/updated with the expected content. For example, verify a sample entry in menu.json corresponds to a row in LiveMenu.xlsx.</Command>
          </Commands>
          <Config><![CDATA[
const XLSX = require('xlsx');
const workbook = XLSX.readFile('data/LiveMenu.xlsx');
const firstSheet = workbook.SheetNames[0];
const data = XLSX.utils.sheet_to_json(workbook.Sheets[firstSheet], {defval: ""});
const fs = require('fs');
fs.writeFileSync('data/menu.json', JSON.stringify(data, null, 2));
]]></Config>
          <Verification>After running the conversion script, open data/menu.json to ensure it contains well-formed JSON reflecting the Excel data (e.g., check that all rows and columns from the Excel appear as JSON objects with correct keys and values). Ensure no error messages appeared during execution.</Verification>
          <RollBack>If the script fails or the JSON output is incorrect (e.g., missing fields or formatting issues), debug by logging the intermediate data or checking for inconsistent Excel data. Correct the script or Excel content as needed and rerun. If menu.json was partially written incorrectly, delete or overwrite it with a corrected output once the script is fixed.</RollBack>
        </Step>
        <Step id="2.1.3">
          <Task>Integrate data build step into deployment pipeline</Task>
          <OwnerRoles>
            <Role>DevOps Engineer</Role>
            <Role>Back-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Add a build script in package.json to automate the data conversion. For example, under "scripts", add "build": "node convertMenu.js" (along with any other build steps like CSS compilation).</Command>
            <Command>Verify the build script locally by running npm run build; confirm it regenerates menu.json from the Excel file successfully. This ensures that whenever deployment runs the build, the latest Excel data is converted.</Command>
            <Command>Commit the updated package.json, convertMenu.js, and initial menu.json to the repository. Do not add node_modules or package-lock.json (they will be installed during deployment).</Command>
          </Commands>
          <Verification>Inspect the GitHub repository to confirm the package.json has the new "build" script and that the convertMenu.js file is present. On a fresh clone, running npm install then npm run build should produce menu.json without errors.</Verification>
          <RollBack>If the integration fails (e.g., syntax error in package.json or script not found), revert the last commit on the branch, fix the issue, and recommit. Ensure the build script is correctly defined. If the build step is not desired to run on every deploy (for quick text-only changes), document how to skip it, but the default pipeline should be fixed rather than removing the step.</RollBack>
        </Step>
      </Batch>
      <Batch id="2.2" name="Front-End Implementation">
        <Step id="2.2.1">
          <Task>Develop responsive user interface with Tailwind CSS</Task>
          <OwnerRoles>
            <Role>Front-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Design the layout of the ordering dashboard: include sections for product listings (populated from the menu JSON) and an order form for user details and selected products. Use semantic HTML5 elements (header, main, form, section) for accessibility.</Command>
            <Command>Integrate Tailwind CSS for styling: initialize Tailwind by installing it (npm install tailwindcss postcss autoprefixer) and creating a Tailwind config (npx tailwindcss init). Configure the content paths to include HTML and PHP files for purge (to remove unused styles).</Command>
            <Command>Create a CSS entry file (e.g., assets/tailwind.css) with Tailwind directives (@tailwind base; @tailwind components; @tailwind utilities;). Add a build step or use PostCSS to compile this to assets/styles.css. Update the package.json "build" script to also run Tailwind, e.g., "build:css": "tailwindcss -i assets/tailwind.css -o assets/styles.css --minify", and combine it with the data conversion (e.g., "build": "tailwindcss -i assets/tailwind.css -o assets/styles.css --minify &amp;&amp; node convertMenu.js").</Command>
            <Command>Apply Tailwind utility classes in the HTML for a responsive design (e.g., use grid or flex classes for layout, spacing classes for padding/margin, typography classes for font sizes). Incorporate responsive variants (sm:, md:, lg:, etc.) to adjust the layout for mobile vs desktop as needed.</Command>
            <Command>Ensure the UI is mobile-first and responsive: include the viewport meta (&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;) and test the layout at various screen sizes. Utilize Tailwind's default responsive breakpoints (sm, md, lg, etc.) to hide, stack, or resize elements on smaller screens appropriately.</Command>
          </Commands>
          <Verification>Open index.html in a web browser and use dev tools to simulate different screen widths. Verify that the layout adjusts (e.g., menu items stack in a single column on mobile vs grid on desktop) and no horizontal scroll appears. All text is legible without zoom, and interactive elements (buttons, form fields) are appropriately sized on mobile. Check that the compiled assets/styles.css is loaded and contains Tailwind utility styles (inspect elements to see Tailwind classes applied).</Verification>
          <RollBack>If the Tailwind setup fails (e.g., CSS not applying or build errors), revert CSS changes and use the Tailwind CDN as a temporary fallback (by adding &lt;script src="https://cdn.tailwindcss.com"&gt; in HTML) while troubleshooting. If the UI is not responsive or has layout issues, adjust the Tailwind classes or breakpoints and retest; if necessary, revert to a simpler layout and build up again in smaller increments to isolate problematic styles.</RollBack>
        </Step>
        <Step id="2.2.2">
          <Task>Display menu data dynamically on the page</Task>
          <OwnerRoles>
            <Role>Front-End Developer</Role>
            <Role>Back-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Add a script to fetch and render the product menu from menu.json. For example, include an assets/menu.js file and load it via a &lt;script&gt; tag at the bottom of index.html.</Command>
            <Command>In assets/menu.js, use the Fetch API to retrieve data/menu.json (assuming it's deployed as static content). On success, dynamically create HTML elements or use a template to insert each product into the product list section (e.g., generate list items or cards with name, description, price). Ensure this runs after the DOM is loaded (place script at end of body or use DOMContentLoaded event).</Command>
            <Command>Implement basic error handling for data load (e.g., if fetch fails, display an error message or fallback content so the page isn't blank).</Command>
            <Command>If the menu data is small and fairly static, consider embedding it directly by inlining a &lt;script type="application/json" id="menu-data"&gt; containing the JSON to avoid an extra fetch; however, using a separate file allows easier updates and caching. Ensure appropriate caching (to be configured later) so updates propagate in a timely manner.</Command>
          </Commands>
          <Verification>Load the page in a local or staging environment and confirm that product entries appear on the page, matching the content of LiveMenu.xlsx. Use the browser dev tools network panel to ensure menu.json is requested and loaded (HTTP 200). Check the console for any JavaScript errors and confirm none occur.</Verification>
          <RollBack>If the data does not display, use dev tools to diagnose (check console for script errors, ensure the menu.json path is correct and the JSON is accessible in the deployed environment). If fetch is failing due to path issues, adjust the path or ensure the JSON is included in the deployment output. As a quick rollback, hardcode a few sample products in the HTML so the page isn't empty, then fix the dynamic loading for a future commit (removing the hardcoded entries once the dynamic load works).</RollBack>
        </Step>
        <Step id="2.2.3">
          <Task>Implement client-side form validation and spam protection</Task>
          <OwnerRoles>
            <Role>Front-End Developer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Create an order form within index.html for users to submit orders or inquiries. Include fields such as customer name, contact info (email/phone), and an order details field or product selection. Mark required fields with the required attribute and use appropriate input types (e.g., &lt;input type="email"&gt; for email).</Command>
            <Command>Add client-side validation using HTML5 and/or JavaScript: for example, ensure the email field contains a valid email format (browser default validation covers basics), ensure no required field is empty, and potentially validate that an order detail or product selection is provided.</Command>
            <Command>Implement a simple spam prevention mechanism: include a hidden honeypot field in the form (e.g., &lt;input type="text" name="company" style="display:none"&gt;). Real users will leave it blank (it's invisible); bots often fill all fields, so if this field comes back with content, the submission can be identified as spam and ignored.</Command>
            <Command>Write a bit of JavaScript to enhance validation and spam check if needed: on form submit, check that the honeypot field is empty (indicating a human user). Optionally disable the submit button upon click to prevent duplicate submissions, and provide user feedback (like a loading indicator or message) while awaiting response.</Command>
          </Commands>
          <Verification>Attempt to submit the form in various scenarios: leave required fields blank to confirm browser/JS validation prevents submission; enter an invalid email to see a validation message; fill the honeypot via dev tools and ensure the form either does not submit or the server will catch it (to be verified in server-side logic). For a valid submission (honeypot empty, all required fields filled with valid data), ensure the form proceeds to submission (which will be handled by the PHP script).</Verification>
          <RollBack>If client-side validation is not functioning, ensure the script is correctly referenced and that no JS errors are thrown. If needed, rely on HTML5 validation alone by using proper input types and required attributes to block bad inputs. If the honeypot approach appears insufficient (some advanced bots might bypass it), plan to introduce a stronger measure (like reCAPTCHA) in the future; for now, proceed while monitoring for spam submissions post-launch.</RollBack>
        </Step>
      </Batch>
      <Batch id="2.3" name="Back-End Implementation">
        <Step id="2.3.1">
          <Task>Develop server-side order processing script with PHPMailer</Task>
          <OwnerRoles>
            <Role>Back-End Developer</Role>
            <Role>Security Engineer</Role>
          </OwnerRoles>
          <Commands>
            <Command>Install PHPMailer via Composer: add a composer.json in the project root (if not already present) and require PHPMailer (composer require phpmailer/phpmailer). This will generate composer.lock and a vendor/ directory with PHPMailer when installed. Commit composer.json and composer.lock (but not the vendor/ directory) to the repo, as dependencies will be installed during deployment.</Command>
            <Command>Implement orderSubmit.php: this PHP script will handle the form POST request. Start by loading PHPMailer (e.g., include Composer's autoload with require 'vendor/autoload.php';). Retrieve and sanitize form fields from $_POST (use filter_input or htmlspecialchars to avoid XSS or email header injection).</Command>
            <Command>Check the honeypot field server-side: if the hidden field (e.g., $_POST['company']) is not empty, treat the submission as spam and do not send an email (optionally log or silently discard).</Command>
            <Command>Use PHPMailer to send the order email: configure SMTP with the credentials obtained. Set SMTP server (Host), enable SMTPAuth, set Username and Password from environment variables, choose SMTPSecure (TLS) and Port (e.g., 587). Set the From address (e.g., from the business's orders email) and add the business's receiving email address as a recipient. Compose the email body with the order details (customer info and requested products).</Command>
          </Commands>
          <Config><![CDATA[
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;

require 'vendor/autoload.php';

\$mail = new PHPMailer(true);
\$mail->isSMTP();
\$mail->Host = getenv('SMTP\_HOST');    // SMTP server
\$mail->SMTPAuth = true;
\$mail->Username = getenv('SMTP\_USER'); // SMTP username
\$mail->Password = getenv('SMTP\_PASS'); // SMTP password
\$mail->SMTPSecure = PHPMailer::ENCRYPTION\_STARTTLS;
\$mail->Port = getenv('SMTP\_PORT') ?: 587;  // SMTP port, default 587

// Set email content
\$mail->setFrom(getenv('SMTP\_FROM'), 'Order Notifications');
\$mail->addAddress('[orders@examplecannabis.com](mailto:orders@examplecannabis.com)');   // destination inbox
\$mail->Subject = 'New Order from Website';
\$mail->Body    = \$emailBodyText;  // \$emailBodyText composed from form fields
\$mail->send();
]]></Config> <Commands> <Command>Compose the email body (\$emailBodyText) to include all relevant order details: list the customer information and requested items (if multiple items can be selected, iterate through them). Use plaintext or simple HTML for the email body (PHPMailer allows either). Ensure special characters are handled (PHPMailer defaults to UTF-8).</Command> <Command>After attempting to send, handle success or failure: if \$mail->send() throws an Exception or returns false, log the error (to a secure log) and consider notifying an admin; if it succeeds, redirect or respond with a "order received" confirmation message for the user (could be a thank-you page or message on the same page).</Command> </Commands> <Verification>Use a test email account or service (like Mailtrap) to verify that the email sending works. Submit the form with test data on a staging environment: ensure an email is received at the designated recipient with the correct subject and content. Also verify that if the honeypot was filled (simulate by forcing that field), no email is sent. Check the PHP error log for any error output from orderSubmit.php.</Verification> <RollBack>If emails are not sending, check PHPMailer's error output. Common issues include incorrect SMTP credentials or ports, or host firewalls blocking the connection. Temporarily adjust settings (e.g., try a different SMTP server or enable less secure app access if using Gmail for testing) to identify the issue. As a fallback, allow the form to submit and display a message like "We will contact you to confirm your order" (so that the business can manually handle it) until the email issue is resolved. If the PHP script causes any site errors, quickly comment out the email-sending code and deploy a hotfix that simply stores the order (to not lose data) while you fix the email functionality.</RollBack> </Step> <Step id="2.3.2"> <Task>Implement server-side logging and security measures</Task> <OwnerRoles> <Role>Back-End Developer</Role> <Role>Security Engineer</Role> </OwnerRoles> <Commands> <Command>Set up optional order logging: within orderSubmit.php, after sending the email, append the order details to a server-side log file (e.g., data/orders.log) for backup. Include a timestamp and the key fields (but avoid sensitive personal data beyond what is needed for order fulfillment). Use file\_put\_contents in append mode or similar mechanism.</Command> <Command>Secure the log and data files: update the web server configuration (.htaccess for Apache on IONOS) to prevent public access to sensitive files in /data. For example, deny access to .xlsx and .log files:</Command> </Commands> <Config><![CDATA[
<FilesMatch "\.(xlsx|log)$">
Require all denied
</FilesMatch>
]]></Config> <Commands> <Command>Implement additional security in PHP: disable display of errors in production (ini\_set('display\_errors', 0)) so that any PHP errors won't reveal sensitive paths or info to users. Ensure the PHP configuration (or .htaccess via php\_flag) has display\_errors off. Continue to validate and sanitize all inputs on the server side (for example, use filter\_var for emails, and limit input lengths) to reduce risk of malicious input causing issues.</Command> <Command>Test the logging and security: after a test form submission, verify that an entry was added to data/orders.log on the server (accessible via SFTP or IONOS file browser). Attempt to access LiveMenu.xlsx or orders.log via a browser (e.g., [https://staging.example.com/data/LiveMenu.xlsx](https://staging.example.com/data/LiveMenu.xlsx)) to ensure the server responds with 403 Forbidden or similar, confirming the .htaccess rules are working.</Command> </Commands> <Verification>Ensure that data/orders.log contains the expected entry after a test submission and that no sensitive info (like passwords) is logged. Accessing any .xlsx or .log file via HTTP should be blocked (forbidden response). Also, review phpinfo or IONOS settings to confirm display\_errors is off in production environment.</Verification> <RollBack>If log entries are not appearing, check file permissions on data/orders.log (the PHP process may need write permission). Adjust if needed (IONOS environments typically allow writing to project files by default). If the .htaccess rule is misconfigured and blocks needed files or isn't working, correct it (make sure AllowOverride is on for that directory, and syntax is right). In an urgent scenario, temporarily remove or rename the sensitive files until proper rules are in place. Always test new .htaccess rules on staging before applying to production to avoid unexpected access issues.</RollBack> </Step> </Batch> </Phase> <Phase id="3" name="Continuous Integration &amp; Deployment Setup"> <Batch id="3.1" name="CI/CD Pipeline Integration"> <Step id="3.1.1"> <Task>Connect GitHub repository to IONOS Deploy Now</Task> <OwnerRoles> <Role>DevOps Engineer</Role> </OwnerRoles> <Commands> <Command>In the IONOS Deploy Now dashboard, create a new project and authorize it to connect to the GitHub repository (cannabis-order-dashboard). Select the main branch as the deployment branch for production.</Command> <Command>Choose the project type as "PHP" (since our project includes PHP code). The setup wizard may auto-detect some build steps; if not, proceed and prepare to customize the CI workflow file to include Node and Composer steps.</Command> <Command>Configure basic settings: name the project (e.g., "CannabisOrderDashboardProd"), and note the temporary preview domain IONOS provides. Enable staging deployments (so that pushes to other branches like dev produce staging deployments automatically).</Command> <Command>Initiate the first deployment through the IONOS interface. This will trigger creation of a GitHub Actions workflow file in the repository (.github/workflows) and start a CI/CD pipeline. The first build may fail until we configure the build steps; this is expected.</Command> </Commands> <Verification>Check the GitHub repository after linking: a workflow YAML (likely named ionos.yml) should appear under .github/workflows. In IONOS Deploy Now, the project should show a deployment attempt. This confirms the GitHub integration is working.</Verification> <RollBack>If the repository connection fails, ensure the GitHub account authorized IONOS and that the repo exists and is accessible. If a wrong branch or project type was selected, delete the IONOS project and redo the setup correctly. No code changes occur here, so rollback mainly involves redoing the linkage properly.</RollBack> </Step> <Step id="3.1.2"> <Task>Configure build and deployment workflow</Task> <OwnerRoles> <Role>DevOps Engineer</Role> <Role>Back-End Developer</Role> </OwnerRoles> <Commands> <Command>Open the GitHub Actions workflow file (ionos.yml or similar) in the repository and edit it to include Node.js and Composer steps. For example, use actions/setup-node\@v3 to install Node 18, run npm ci and npm run build (to generate CSS and JSON), then use shivammathur/setup-php\@v2 to set up PHP 8 and run composer install --no-dev.</Command> <Command>Ensure the workflow deploys to IONOS: use the IONOS Deploy Now action or the default configured step to push the built output. The final part of the YAML might use ionos-deploy-now/actions\@v2 to handle deployment, which uses the GITHUB\_TOKEN by default.</Command> <Command>Commit the updated workflow file. This will trigger a new GitHub Actions run. Monitor the run in the Actions tab: verify that the Node build step executes (install dependencies and outputs CSS/JSON), the Composer step runs (installing PHPMailer), and the deployment step finishes successfully.</Command> <Command>Also ensure the workflow is set to run on relevant branches (main for production, and dev for staging if needed). If not, adjust the on: section to include pushes to dev or enable multi-deployment in IONOS for dev branch.</Command> </Commands> <Config><![CDATA[
name: Deploy to IONOS
on:
push:
 branches: [ "main", "dev" ]
jobs:
build-deploy:
 runs-on: ubuntu-latest
 steps:
   - uses: actions/checkout@v3
   - uses: actions/setup-node@v3
     with:
       node-version: '18.x'
   - run: npm ci
   - run: npm run build
   - uses: shivammathur/setup-php@v2
     with:
       php-version: '8.0'
   - run: composer install --no-dev
   - name: Deploy
     uses: ionos-deploy-now/actions@v2
     with:
       github_token: ${{ secrets.GITHUB_TOKEN }}
]]></Config> <Verification>Observe a successful pipeline run on GitHub Actions (all steps green). In the IONOS dashboard, the project should show a successful deployment. Check that the deployed environment has the expected files: index.html, assets/styles.css, data/menu.json, orderSubmit.php, etc. You can verify via the IONOS "view files" feature or by testing the site.</Verification> <RollBack>If the workflow fails at any step, examine the log output. Fix issues accordingly (e.g., if npm run build fails, ensure all commands and paths are correct; if composer fails, maybe add an extension like mbstring using setup-php's options). Commit fixes and re-run. If deployment fails due to IONOS config, ensure the action is correctly used and the project name matches (if needed by the action). In worst case, revert to the previously working workflow (the one IONOS initially provided) to keep deploying a simpler version, and address the CI issues offline.</RollBack> </Step> <Step id="3.1.3"> <Task>Set environment variables for secure credentials</Task> <OwnerRoles> <Role>DevOps Engineer</Role> <Role>Project Manager</Role> </OwnerRoles> <Commands> <Command>Store sensitive credentials as environment secrets. In GitHub repo settings, add Actions secrets for SMTP\_HOST, SMTP\_USER, SMTP\_PASS, SMTP\_PORT, and SMTP\_FROM (using values from the earlier email account setup or IONOS-provided mail service). These will be used during deployment.</Command> <Command>In IONOS Deploy Now, configure these secrets for runtime. Deploy Now uses GitHub Secrets by default if we set up a template. Create a .deploy-now directory in the repo with a production.env.template file containing placeholders, e.g. SMTP\_HOST={{ .secrets.SMTP\_HOST }} and similarly for the other variables. During deployment, IONOS will replace these with the real values and create a .env file on the server.</Command> <Command>Modify orderSubmit.php to retrieve SMTP credentials from environment (getenv('SMTP\_USER') etc., as done in code). Ensure no secrets are hard-coded in the codebase. The PHPMailer configuration should already be using getenv() from the earlier step.</Command> <Command>Verify the environment setup by doing a test deploy to staging: ensure that the email still sends (which indicates the secrets are correctly set). You might temporarily output phpinfo on staging to confirm the values are present (but avoid exposing them on production).</Command> </Commands> <Config><![CDATA[
SMTP_HOST={{ .secrets.SMTP_HOST }}
SMTP_USER={{ .secrets.SMTP_USER }}
SMTP_PASS={{ .secrets.SMTP_PASS }}
SMTP_PORT={{ .secrets.SMTP_PORT }}
SMTP_FROM={{ .secrets.SMTP_FROM }}
]]></Config> <Verification>In the IONOS Deploy Now dashboard, confirm that the secrets are listed (or the template applied) and that the site is using them (no errors connecting to SMTP on test emails). Submit a test order on staging or production after setting the secrets; if the email sends successfully, it implies the environment variables were correctly applied.</Verification> <RollBack>If secrets are not being applied (e.g., emails still fail due to auth), double-check that the secret names in GitHub match those in the template. If needed, set environment variables directly in IONOS's interface for the project and redeploy. Never commit the actual secrets to code. If a secret was accidentally exposed, immediately rotate that credential (change the password or key) and update the secret store. Redeploy once corrected.</RollBack> </Step> </Batch> <Batch id="3.2" name="Staging Environment Setup"> <Step id="3.2.1"> <Task>Establish a staging deployment for testing</Task> <OwnerRoles> <Role>DevOps Engineer</Role> </OwnerRoles> <Commands> <Command>Ensure "Staging deployments" is enabled in IONOS Deploy Now. Push the latest code to the dev branch. IONOS will automatically deploy this branch to a staging environment (accessible via a generated preview URL, e.g., dev--projectid.deploy-now\.site).</Command> <Command>Verify the staging deployment in the IONOS dashboard: it should list the dev branch as an active deployment with its own URL. The CI/CD workflow run for dev should be visible in GitHub Actions (mirroring the main pipeline steps).</Command> <Command>Test the staging site: open the preview URL. It should be an exact copy of the site but on a different domain. Use this for final QA tests. Optionally, you can have the staging environment use a different SMTP configuration (e.g., secrets for a test email address) to avoid sending test emails to the real inbox; this can be achieved by adding separate secrets or overriding the recipient in code when on staging.</Command> </Commands> <Verification>The staging site loads and functions as expected. All features (menu display, form submission) work on staging. When a test form is submitted on staging, it should send an email to the test mailbox or at least attempt with test credentials, confirming the back-end works in the staging environment as well.</Verification> <RollBack>If staging deployment does not appear or fails, check that the GitHub workflow is triggered for dev branch (if not, modify the on: branches in the YAML as done). If still failing, consider manually setting up a separate IONOS project for the dev branch as staging. If staging site is up but experiencing errors that production did not, use this to fix issues prior to launch. Staging issues should not block production launch if they can be resolved; treat them as an opportunity to catch bugs.</RollBack> </Step> </Batch> </Phase> <Phase id="4" name="Domain Configuration &amp; TLS"> <Batch id="4.1" name="Custom Domain Linking"> <Step id="4.1.1"> <Task>Link custom domain to production deployment</Task> <OwnerRoles> <Role>DevOps Engineer</Role> <Role>IT Administrator</Role> </OwnerRoles> <Commands> <Command>In the IONOS Deploy Now project settings, add the custom domain (orders.examplecannabis.com) to the production deployment. If the domain is registered through IONOS, this is a simple selection; if external, follow instructions to point DNS to IONOS (often by changing the domain's nameservers to IONOS's or adding A/CNAME records).</Command> <Command>For an external domain, update the nameservers at the registrar to IONOS's (if required), or create the provided DNS records (A record to IONOS IP or CNAME to a deploy-now address). Wait for DNS propagation once changes are made.</Command> <Command>IONOS will provision the domain and verify ownership (nameserver switch typically handles this). In the IONOS interface, watch for the domain status to become "connected". This can take some time depending on DNS TTLs.</Command> </Commands> <Verification>The IONOS dashboard shows the custom domain as active/connected. Using a DNS lookup (dig or nslookup) on orders.examplecannabis.com shows it resolving to IONOS. Navigating to [http://orders.examplecannabis.com](http://orders.examplecannabis.com) (note, not https yet) should reach the site (it might redirect to https or show the site if not forcing SSL yet).</Verification> <RollBack>If the domain linking fails (e.g., DNS misconfiguration), double-check the domain settings. If needed, revert DNS changes (point back to old site or parking) until a maintenance window. Inform stakeholders if there's any expected downtime or propagation delay. As a temporary measure, the site can still be accessed on the IONOS preview URL until the domain issues are resolved.</RollBack> </Step> <Step id="4.1.2"> <Task>Enable and verify HTTPS (TLS certificate)</Task> <OwnerRoles> <Role>DevOps Engineer</Role> </OwnerRoles> <Commands> <Command>IONOS Deploy Now automatically provisions an SSL/TLS certificate (via Let's Encrypt) for connected domains. After the domain is connected, it will attempt to get a certificate. No manual action is needed except to wait for it to complete (usually within minutes).</Command> <Command>Test secure access: navigate to [https://orders.examplecannabis.com](https://orders.examplecannabis.com) once the certificate is issued. The site should load without browser warnings. Check certificate details to confirm it's issued to the correct domain and is valid (Let's Encrypt 90-day cert, auto-renewing).</Command> <Command>Force HTTPS for all traffic: update .htaccess with a redirect rule to ensure any http requests are redirected to https. For Apache, one can use:</Command> </Commands> <Config><![CDATA[
<If "%{HTTPS} == 'off'">
RewriteEngine On
RewriteRule ^(.*)$ https://%{HTTP_HOST}/$1 [R=301,L]
</If>
]]></Config> <Commands> <Command>Deploy this .htaccess change. After deployment, verify by visiting the http URL ([http://orders.examplecannabis.com](http://orders.examplecannabis.com)) and confirming it automatically redirects to the https URL.</Command> </Commands> <Verification>The site is accessible only via HTTPS. The browser shows a lock icon; no "Not Secure" warnings. All resources load over HTTPS (check that there are no mixed-content warnings in dev console). The redirect from HTTP to HTTPS works properly (HTTP URLs get 301 redirected).</Verification> <RollBack>If HTTPS is not working (e.g., certificate not issued or has errors), do not enforce redirect until resolved. Continue to troubleshoot domain linking or certificate issuance (check if domain is properly pointed, or if Let's Encrypt challenge failed possibly due to DNS). Contact IONOS support if needed. If for some reason HTTPS cannot be enabled by launch, communicate with the client about the risk and possibly use the IONOS provided domain (which has SSL) temporarily. Remove or comment out the redirect rule if it causes issues, to allow HTTP access until SSL is fixed (though this is not ideal for security, it might keep the site accessible).</RollBack> </Step> <Step id="4.1.3"> <Task>Finalize domain configuration</Task> <OwnerRoles> <Role>Project Manager</Role> <Role>DevOps Engineer</Role> </OwnerRoles> <Commands> <Command>Update any references to the preview URL or old URLs to the new custom domain (e.g., in documentation or client communications). Ensure that the site configuration (if any URLs are hard-coded, though unlikely in this static setup) uses the custom domain where appropriate.</Command> <Command>If any site maps or robots.txt are used, update them to reference the new domain. Similarly, if an analytics or search console setup is needed, add the new domain (register it in Google Search Console for example, to monitor indexing).</Command> <Command>Ensure the client has control over the domain's DNS (especially if we changed nameservers). If the domain was external and moved, verify with the client that email or other DNS records for that domain are unaffected (if the domain had other services, those DNS entries must be replicated in IONOS DNS).</Command> <Command>Document the domain setup: record what DNS changes were made and how the TLS is managed (so future maintainers know that TLS is auto-handled by IONOS). Include this in the project documentation.</Command> </Commands> <Verification>The ordering dashboard is now live at the intended domain and accessible via secure HTTPS. Stakeholders can use the domain normally. Tools like SSL Labs can be run to get an A grade on the SSL configuration (IONOS should handle modern TLS well by default). The domain configuration steps are fully completed and documented.</Verification> <RollBack>If any issues remain with the domain (like propagation delays causing some users not reaching the site), consider temporarily making the old site (if one existed) redirect to the new domain to catch stragglers, or communicate to users about the new link. As a fallback, the IONOS preview URL could be kept active as an alternate access until DNS propagation completes. However, once domain and TLS are stable, those measures can be dropped.</RollBack> </Step> </Batch> </Phase> <Phase id="5" name="Testing &amp; Quality Assurance"> <Batch id="5.1" name="Testing in Staging"> <Step id="5.1.1"> <Task>Perform functional testing on staging site</Task> <OwnerRoles> <Role>QA Engineer</Role> <Role>Front-End Developer</Role> </OwnerRoles> <Commands> <Command>Test the entire user journey on the staging site: load the site, verify menu data is displayed and accurate, and attempt to place an order (fill out the form with sample data and submit).</Command> <Command>Verify form behavior: check that client-side validation works (required fields and formatting). Then verify that on submission, a success confirmation is shown (either a thank-you page or message) and no error is visible to the user.</Command> <Command>Check that a test order submission results in an email being sent to the configured address (or test address). Ensure the email content matches the form input. Also verify that an order log entry was created if logging is enabled.</Command> <Command>Validate spam protection: attempt a submission with the honeypot field filled (manually via browser dev tools) and confirm that such submission does not trigger an email and is perhaps logged differently or ignored.</Command> <Command>Conduct negative tests: try to break the form by inputting script tags or SQL keywords in fields to see if any vulnerability is present (they should just be treated as plain text in the email/log). Ensure no part of the system is exposing stack traces or sensitive information when given bad inputs.</Command> </Commands> <Verification>All critical functionality works on staging: The menu is correct and up-to-date. The form can be submitted successfully and results in an email to the test inbox (with correct details and formatting). Validation prevents bad input, and spam submissions are ignored. No security issues are evident (malicious inputs do not cause any obvious issues).</Verification> <RollBack>If any issues are discovered, fix them before production launch. For example, if the email format is wrong or missing info, adjust orderSubmit.php to include it. If validation is inadequate, improve the JS or add server checks. If any part of the flow fails (no email received, etc.), debug on staging until resolved. Do not deploy to production until these issues are addressed and re-tested on staging.</RollBack> </Step> <Step id="5.1.2"> <Task>Conduct performance and compatibility testing</Task> <OwnerRoles> <Role>QA Engineer</Role> <Role>Front-End Developer</Role> </OwnerRoles> <Commands> <Command>Test the site on multiple browsers (Chrome, Firefox, Safari, Edge) and devices (desktop, tablet, smartphone). Ensure the layout is consistent and there are no browser-specific errors in the console.</Command> <Command>Run a performance test (using Google PageSpeed Insights or Lighthouse on the staging URL). Check metrics like First Contentful Paint and overall performance score. The site is static so it should be fast; verify Tailwind CSS is optimized (thanks to purge, the CSS file should not be huge). Ensure images (if any) are optimized and that there's no render-blocking issues beyond a minimal CSS.</Command> <Command>Verify caching: ensure that static assets (CSS, JS, JSON) are being cached by the browser. Use dev tools to inspect response headers for Cache-Control on these files. If not present or not optimal, plan to add headers (like a long max-age for CSS/JS and maybe a short one for JSON if we want frequent update checks).</Command> <Command>Test resilience: if possible, simulate a scenario of high load (though not easy without tools - even just opening multiple tabs or using online load test services lightly since it's static). Everything should still function due to the static nature of the site and email being the only dynamic part (which could be a bottleneck if too many come at once, but not likely at initial scale).</Command> <Command>Verify that updating the Excel and redeploying would reflect changes properly (this is more of a process test): update something minor in LiveMenu.xlsx (like a product name), go through the commit and deploy on staging, and ensure the change appears on the staging site. This validates our update process and CI pipeline end-to-end one more time.</Command> </Commands> <Verification>The site scores well in performance tests (e.g., high 90s in Lighthouse for performance). No major differences across browsers; all features work on mobile (touch interactions, form input, etc.). Caching is appropriately applied (repeat visits load faster due to cached assets, but data updates still propagate because either JSON is not heavily cached or we will manage cache-busting). The Excel update test shows that content changes flow through the pipeline and show up on the site as expected.</Verification> <RollBack>If performance is subpar, consider enabling compression (IONOS likely already serves gzip/Brotli). Remove any unnecessary large scripts (not expected here). If caching is not as desired, adjust .htaccess to set Cache-Control headers (for example, long max-age for static assets like CSS/JS, and maybe no-cache or a short max-age for menu.json to ensure fresh data on each visit). Document any such changes and test again. Ensure these adjustments do not negatively impact functionality (e.g., too aggressive caching of JSON could show stale menu; mitigate by versioning if necessary).</RollBack> </Step> <Step id="5.1.3"> <Task>Perform security assessment on staging</Task> <OwnerRoles> <Role>Security Engineer</Role> <Role>QA Engineer</Role> </OwnerRoles> <Commands> <Command>Review the site for common security issues. Use browser developer tools to ensure no sensitive data is exposed in the source (e.g., search the rendered HTML and JS for any leftover API keys or secrets—there should be none since we use env variables).</Command> <Command>Test for XSS: input something like "\<script>alert('xss')\</script>" in form fields (name or order details) and submit. The script tags should appear literally in the received email or log (since we encode or treat as plain text), and should not execute anywhere on the site. Since the site itself doesn't display submitted data, XSS risk is minimal on frontend; the main risk would be if an admin opens the log in a browser without sanitizing, but the log is text.</Command> <Command>Ensure HTTP headers for security are in place: check responses for headers like X-Content-Type-Options: nosniff, X-Frame-Options: SAMEORIGIN, Content-Security-Policy, etc. IONOS might set some by default. If any are missing and desired, plan to add them via .htaccess (e.g., Header set X-Content-Type-Options "nosniff"). CSP might be liberal (since it's a simple site, you can set a strict CSP allowing only self, perhaps).</Command> <Command>Examine the form submission process: ensure that it is only accessible via the site (we may not have explicit CSRF protection because there's no session, but the obscurity and one-time nature might be acceptable; however, note this risk). Since it's a public form, CSRF isn't a big issue (anyone can submit anyway), but we should confirm no misuses (like email header injection—our PHPMailer usage should handle that). We already validated against header injection by not directly using mail() and by sanitizing inputs.</Command> <Command>Optionally, run a vulnerability scan using a tool like OWASP ZAP on the staging site. This can catch any missed issues (like missing security headers or potential injection points). Address any high or medium findings from such a scan.</Command> </Commands> <Verification>No security vulnerabilities are identified. The test script injection appears harmless in the email/log (not executed in any context). The site does not reveal any secret info. Security headers are present or have been added as needed (no glaring omissions). The OWASP ZAP report (if run) shows no serious issues, or any minor ones have been acknowledged and mitigated.</Verification> <RollBack>If any vulnerabilities are found, fix them before production push. For example, if CSP is missing and considered necessary, add one (be careful to not break any functionality; in our case, maybe allow 'self' and inline styles if any, etc.). If security headers like X-Frame-Options are missing, add them. If any form of injection seems possible, double down on input sanitization or output encoding. The rollback here is essentially delaying launch until issues are fixed; do not proceed to production with known security issues if at all possible. If a critical issue is discovered after launch, take the site offline (disable form or whole page) until a fix is deployed.</RollBack> </Step> </Batch> <Batch id="5.2" name="Production Launch Verification"> <Step id="5.2.1"> <Task>Deploy to production and smoke test</Task> <OwnerRoles> <Role>DevOps Engineer</Role> <Role>Project Manager</Role> </OwnerRoles> <Commands> <Command>Merge the dev (staging) branch into main (production) once all tests are passed and approved. This will trigger the CI/CD pipeline to deploy the latest code and data to production on IONOS.</Command> <Command>Perform a smoke test on the production site (orders.examplecannabis.com). Verify that the homepage loads correctly. Quickly run through critical paths: does the menu display? Does the form validate? Try a test order submission (perhaps using a test name like "Test Order - Please Ignore").</Command> <Command>Verify that the test order email is received in the actual business inbox (or designated production recipient). Ensure the content is correct. Check the server log (if logging enabled) to see that the entry is recorded.</Command> <Command>Monitor the IONOS runtime logs for a short period after launch (e.g., any PHP error logs accessible via the Deploy Now interface) to see if any errors occur under real usage. Also keep an eye on the site uptime ( it should remain stable post-deployment ).</Command> </Commands> <Verification>The production site is functioning identically to the staging site. The quick test shows that orders can be placed and emails are delivered to the business. No errors are observed. The business can see the test email, confirming the system is live. All references now point to the production domain, and users are using the live site.</Verification> <RollBack>If any critical issue is discovered on production (that somehow slipped through staging), immediately decide on a rollback: either fix forward if trivial (small configuration tweak) or roll back to previous deployment. Rolling back on IONOS could mean redeploying an earlier commit or temporarily reverting the main branch to a known good commit and letting CI deploy that. If the issue is domain related or emailing, and cannot be fixed in minutes, consider putting up a maintenance page (even a simple static "We'll be back soon" page) to pause orders until resolved. Communicate with the business if any such emergency action is taken.</RollBack> </Step> <Step id="5.2.2"> <Task>Obtain final approval and stakeholder sign-off</Task> <OwnerRoles> <Role>Project Manager</Role> <Role>Business Owner</Role> </OwnerRoles> <Commands> <Command>Notify the business stakeholders that the site is live on production. Provide them the URL and request they perform a quick run-through from their perspective (maybe placing a test order themselves to see the process).</Command> <Command>Walk the stakeholders through the admin side of things: ensure they know to check the designated email for new orders, and how to interpret the order emails. If a log is kept, let them know how to securely retrieve it if needed (or that it exists for audit purposes).</Command> <Command>Have the business owner or client formally approve the deployment. This could be via an email stating that the system meets their requirements and is accepted. This sign-off is important to officially close the deployment phase.</Command> <Command>Document the launch in a project closure report: include the date/time of launch, any deviations from plan, and the sign-off confirmation. Also schedule a post-launch review meeting if needed to gather initial user feedback and ensure everything continues to run smoothly.</Command> </Commands> <Verification>The business owner and relevant stakeholders indicate that they are satisfied with the live system. All required features from the plan PDF are present and working. The team receives formal acceptance (e.g., an email from the client saying "Looks good, thank you"). This marks the successful deployment of the ordering dashboard.</Verification> <RollBack>If the stakeholder identifies any critical issue during their final review that was not caught earlier, address it immediately. If it's a minor tweak (text change, etc.), it can go through a quick fix directly on production (with stakeholder approval). If it’s more substantial, treat it as a new change request (see ChangeControl) and possibly roll back the feature (if possible) while reworking it. Ensure the stakeholder is comfortable with proceeding; if not, one may consider the site still in "staging" in their eyes and delay the official launch announcement until that issue is resolved.</RollBack> </Step> </Batch> </Phase> <Phase id="6" name="Maintenance &amp; Monitoring"> <Batch id="6.1" name="Monitoring and Support"> <Step id="6.1.1"> <Task>Monitor site uptime and performance</Task> <OwnerRoles> <Role>DevOps Engineer</Role> <Role>Project Manager</Role> </OwnerRoles> <Commands> <Command>Set up an uptime monitoring service for the production URL (if not already) to alert the team of any downtime. This could be a simple free service pinging the site every few minutes.</Command> <Command>Regularly review the performance of the site using analytics or monitoring. Since it's static, performance issues are unlikely, but keep an eye on email sending performance. If the volume of orders/email grows, ensure the SMTP service can handle it (and not classify traffic as spam).</Command> <Command>Monitor error logs on IONOS. Occasionally check the server logs (e.g., via IONOS Deploy Now "View logs") to see if there are PHP warnings/errors occurring that didn't surface during testing (like edge cases in form input causing undefined indexes, etc.). Address any such issues proactively.</Command> <Command>Ensure TLS certificate renewals happen: mark a reminder around 60-80 days post-launch to verify that Let's Encrypt auto-renewal is working (though IONOS should handle it, it's good to double-check that the certificate updates before expiration).</Command> </Commands> <Verification>The site remains up continuously, with any downtime alerts being rare or false alarms. The performance stays within acceptable parameters (pages load quickly, and email notifications are delivered promptly). Regular checks show no critical errors accumulating in logs. TLS certificates renew without issue (no downtime or warnings from browsers).</Verification> <RollBack>If the monitor alerts downtime, immediately investigate: check IONOS status, or if a deployment caused an outage, consider rolling back that deployment. If performance slows (perhaps due to enormous traffic), consider scaling solutions (though on static hosting that's usually not a problem—IONOS can handle quite some traffic, or one could move to a CDN). If any systemic issue is detected (like repeated PHP warnings), plan a maintenance patch release to fix it before it becomes a bigger problem (e.g., before logs fill up or a minor bug becomes user-visible).</RollBack> </Step> <Step id="6.1.2"> <Task>Provide user support and gather feedback</Task> <OwnerRoles> <Role>Project Manager</Role> <Role>Business Owner</Role> </OwnerRoles> <Commands> <Command>Establish a clear support channel for the client/business. For instance, agree that any issues or change requests should be emailed to the project team or logged in an issue tracker. Make sure the business knows how to reach support if the site has a problem (and provide an expected response time SLA if applicable).</Command> <Command>Gather user feedback after launch. This might involve checking with actual customers or store staff using the dashboard. Are there any usability issues? Are emails structured in a way that's easy for staff to use? Collect these insights for future improvements.</Command> <Command>Schedule periodic reviews (maybe after 1 week and after 1 month of launch) with the stakeholder to discuss how the system is performing and if it meets the business needs. This can also be a time to discuss any minor enhancements (like adding an extra field to the form, or adjusting the menu categories) now that it's in real use.</Command> <Command>Keep documentation up to date. If any changes occur in configuration or process (for example, the client decides to use a different email for orders or adds a second notification recipient), update the deployment plan or runbook to reflect this and perform the necessary adjustments in a controlled manner.</Command> </Commands> <Verification>The business reports that the system is working well and any minor issues are addressed promptly. Users (both customers placing orders and staff receiving them) are satisfied with the experience. All support inquiries are resolved and documented. The project team remains engaged for post-launch support as needed, and the client feels supported.</Verification> <RollBack>If significant issues are reported by end users (e.g., multiple customers say they didn't get confirmation, or staff says some orders didn't come through), treat it as a priority to diagnose. Roll back any recent changes if they are suspect. For instance, if an update to the Excel data caused a parse failure resulting in blank menu, revert to previous Excel and redeploy quickly, then fix the data. Maintain user trust by communicating transparently (e.g., a quick note on the site or via email if there's an outage or known issue while you fix it).</RollBack> </Step> </Batch> <Batch id="6.2" name="Menu Data Updates"> <Step id="6.2.1"> <Task>Update product data via Excel and deploy</Task> <OwnerRoles> <Role>Content Manager</Role> <Role>Back-End Developer</Role> </OwnerRoles> <Commands> <Command>When the menu needs updating (new products, price changes, etc.), the Content Manager will edit the LiveMenu.xlsx file. After making changes (and double-checking formatting), they will save the updated file.</Command> <Command>Trigger a deployment with the new data: if the Content Manager is technical enough to use Git, they can commit the new LiveMenu.xlsx to the repo (preferably on the dev branch first). Otherwise, they send the file to a developer to commit on their behalf.</Command> <Command>After commit, the CI pipeline runs: on dev branch it updates staging. The team or Content Manager verifies the staging site reflects the changes correctly (products added, prices updated). Once confirmed, the changes are merged to main for production deployment.</Command> <Command>For urgent updates (like correcting a price ASAP), the Content Manager may update directly on main branch (via GitHub web UI upload, for example). The pipeline will deploy it to production. However, this bypasses staging testing, so it should be reserved for minor/trivial changes or critical fixes, and still verified on production immediately after.</Command> </Commands> <Verification>The updated menu appears on the live site after deployment, showing all intended changes. For example, if a new product was added in Excel, it now shows up on the site; if a price was changed, the new price is displayed. No layout issues or errors result from the update (the JSON format remained consistent and the front-end handles the new data gracefully).</Verification> <RollBack>If an update causes an issue (e.g., someone accidentally deleted a column in Excel, causing the JSON conversion to break or produce malformed data), immediately roll back to the previous version: retrieve the last good LiveMenu.xlsx from version control and redeploy it. Then fix the Excel file (re-add the column or correct data) and go through the deployment again. The version control history serves as a backup for all past menu states, so you can always revert to a known working state quickly.</RollBack> </Step> <Step id="6.2.2"> <Task>Enhance caching strategy for updated data</Task> <OwnerRoles> <Role>DevOps Engineer</Role> <Role>Front-End Developer</Role> </OwnerRoles> <Commands> <Command>Ensure that when menu data updates, users get the new data promptly. If menu.json is cached by browsers, consider implementing cache-busting: for example, include a version query parameter when fetching (like data/menu.json?v=2025-08-13 or a commit hash) that changes on each deployment, so browsers always fetch the latest.</Command> <Command>Alternatively, set a short cache duration for menu.json. Using .htaccess, one could add Header set Cache-Control "max-age=60, must-revalidate" for the JSON file, meaning browsers will re-fetch it after a minute. The rest of the static assets (CSS, JS) can have a longer cache since they change infrequently and can use content hash if needed.</Command> <Command>Monitor if users or staff report seeing stale data after updates. If so, instruct them to hard refresh as a workaround and prioritize implementing the above cache-busting solutions. Over time, refine the caching configuration to balance freshness and performance.</Command> <Command>Document the caching behavior in the runbook so that during updates, the team knows what to expect (e.g., "once deployed, all users will get new menu within X minutes or on next page load due to cache settings" or "we increment the version query so they always get it immediately").</Command> </Commands> <Verification>After implementing these strategies, when a new menu is deployed, even users with cached sites receive the updated menu the next time they access the site without needing a full hard refresh. Testing using developer tools (disable cache and normal mode) shows the JSON is often fetched anew. This ensures the business information is always current for customers.</Verification> <RollBack>If the cache-busting introduction inadvertently breaks something (for example, if an older deployment's front-end tries to fetch a versioned file that doesn't exist yet), be ready to adjust. Perhaps deploy the front-end code that adds ?v=timestamp slightly before deploying the data change, so there's no mismatch. In any case, if caching causes issues, one can temporarily set menu.json to no-cache (so every visit pulls fresh data) as a safe but slightly less optimized solution until a more robust strategy is in place.</RollBack> </Step> </Batch> <Batch id="6.3" name="Continuous Improvement and Change Management"> <Step id="6.3.1"> <Task>Review and address identified risks periodically</Task> <OwnerRoles> <Role>Project Manager</Role> <Role>Security Engineer</Role> </OwnerRoles> <Commands> <Command>Periodically (e.g., monthly), review the RisksRegister below. For each risk, assess if it's becoming an issue or if mitigation measures are holding. E.g., check spam submission logs to see if honeypot is effectively deterring bots or if a lot of spam still comes through (which might prompt adding reCAPTCHA).</Command> <Command>Update risk statuses: if some risk has been eliminated or reduced (for instance, if the site gets integrated with a more robust system later, maybe some risks go away), note that. Add any new risks that arise (maybe "email account quota" if volume grows, or "compliance changes" if laws change).</Command> <Command>Ensure risk mitigations are tested: e.g., do a quick test that the order email account password is still valid (maybe set a reminder to change it periodically for security, which then needs updating in secrets). For the security risk of outdated dependencies, keep PHPMailer and Node packages updated via periodic maintenance updates.</Command> <Command>Share a summary of risk status with the team and client as appropriate, especially for high-impact risks. This keeps everyone aware and prepared (for instance, if "Email deliverability" is a risk, the business might consider also regularly checking the spam folder or having an alternate contact method just in case).</Command> </Commands> <Verification>No major incidents occur because proactive measures are taken. The project remains in a stable condition with known risks under control. For example, spam submissions might be present but at a manageable level, and no legitimate order emails have been lost. The client feels confident that potential issues are being monitored and handled.</Verification> <RollBack>If a risk turns into an issue despite mitigation (e.g., a wave of spam gets through or the email account gets temporarily blocked due to volume), treat it as an incident: resolve the immediate problem (maybe add a CAPTCHA to stop spam, or contact email provider to unblock and then use a more robust SMTP service). After resolution, re-evaluate that risk's mitigation plan to prevent recurrence (perhaps upgrading the spam prevention or splitting notification emails across multiple addresses, etc.). Document the incident and the changes made in the ChangeControl process.</RollBack> </Step> <Step id="6.3.2"> <Task>Process change requests through change control</Task> <OwnerRoles> <Role>Project Manager</Role> <Role>Business Owner</Role> </OwnerRoles> <Commands> <Command>For any new features or major changes post-launch (e.g., adding an order confirmation email to customers, integrating an inventory system, etc.), initiate a formal change request. Log the request with details of the desired change and rationale.</Command> <Command>Analyze the change: the technical team estimates effort and impact. Update the TraceabilityMatrix to map the change to original requirements if relevant (or mark it as a new requirement R12, R13, etc. if beyond original scope). Assess any new risks the change might introduce.</Command> <Command>Seek approval: present the change request and analysis to the Business Owner and any other decision-makers. If the change is approved (and possibly budgeted), schedule it into development. If not, record that decision and revisit later if needed.</Command> <Command>Implement the change following development best practices: use a feature branch, test in staging, and deploy via the established pipeline. Update RACI roles if the change introduces new responsibilities (like if a database is added, maybe a DBA role gets involved). Update all documentation (ArtifactsIndex, Definitions if new terms arise, etc.) accordingly.</Command> <Command>Follow through with testing and deployment as rigorously as the initial launch. Ensure the change does not disrupt existing functionality (regression testing). Only roll out to production once it passes QA and UAT, and get stakeholder sign-off on the change as well.</Command> </Commands> <Verification>All changes after launch are systematically managed. There's a clear record of what changes were made and why, who approved them, and how they were implemented. The system evolves without chaos, and stakeholders have confidence that any enhancements won't compromise the stability achieved at launch. The TraceabilityMatrix can be extended to include these new requirements and their fulfillment steps, ensuring continuity of documentation.</Verification> <RollBack>If a change, once deployed, causes unexpected issues, use the rollback procedures defined: revert to the previous version if needed (the CI/CD can deploy an older commit if we git revert or git checkout a tag). Manage stakeholder expectations through the ChangeControl process: emergency fixes might be needed, which should also go through approval (at least inform the Business Owner). After rollback, reassess the change implementation, adjust the plan, and attempt again when ready, this time with the issues resolved.</RollBack> </Step> </Batch> </Phase> </WorkBreakdown> <RACI> <Task name="Project Initiation (requirements &amp; resourcing)"> <Responsible>Project Manager</Responsible> <Accountable>Business Owner</Accountable> <Consulted>Technical Lead</Consulted> <Informed>Development Team</Informed> </Task> <Task name="Repository Setup &amp; Initial Structure"> <Responsible>DevOps Engineer</Responsible> <Accountable>Technical Lead</Accountable> <Consulted>Front-End Developer</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="Data Integration (Excel &amp; JSON)"> <Responsible>Back-End Developer</Responsible> <Accountable>Technical Lead</Accountable> <Consulted>Content Manager</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="Front-End Development (UI &amp; UX)"> <Responsible>Front-End Developer</Responsible> <Accountable>Technical Lead</Accountable> <Consulted>UX Designer</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="Back-End Development (PHP &amp; Email)"> <Responsible>Back-End Developer</Responsible> <Accountable>Technical Lead</Accountable> <Consulted>Security Engineer</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="CI/CD Setup &amp; Config"> <Responsible>DevOps Engineer</Responsible> <Accountable>Technical Lead</Accountable> <Consulted>Back-End Developer</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="Domain &amp; TLS Configuration"> <Responsible>DevOps Engineer</Responsible> <Accountable>Technical Lead</Accountable> <Consulted>IT Administrator</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="Quality Assurance Testing"> <Responsible>QA Engineer</Responsible> <Accountable>Project Manager</Accountable> <Consulted>Front-End Developer</Consulted> <Informed>Business Owner</Informed> </Task> <Task name="Security Assessment"> <Responsible>Security Engineer</Responsible> <Accountable>Project Manager</Accountable> <Consulted>DevOps Engineer</Consulted> <Informed>Business Owner</Informed> </Task> <Task name="Production Deployment &amp; Launch"> <Responsible>DevOps Engineer</Responsible> <Accountable>Project Manager</Accountable> <Consulted>Business Owner</Consulted> <Informed>Development Team</Informed> </Task> <Task name="Content Updates (Excel data)"> <Responsible>Content Manager</Responsible> <Accountable>Business Owner</Accountable> <Consulted>Back-End Developer</Consulted> <Informed>Project Manager</Informed> </Task> <Task name="Maintenance &amp; Monitoring"> <Responsible>DevOps Engineer</Responsible> <Accountable>Project Manager</Accountable> <Consulted>Security Engineer</Consulted> <Informed>Business Owner</Informed> </Task> <Task name="Change Control Process"> <Responsible>Project Manager</Responsible> <Accountable>Business Owner</Accountable> <Consulted>Technical Lead</Consulted> <Informed>Development Team</Informed> </Task> </RACI> <ArtifactsIndex> <Artifact> <Name>GitHub Repository</Name> <Description>Version-controlled repository containing all source code, data files, and configuration for the project.</Description> <Location>GitHub (private repo named "cannabis-order-dashboard", including /data, /assets, .github/ workflows, etc.)</Location> </Artifact> <Artifact> <Name>LiveMenu.xlsx</Name> <Description>Excel file storing the live product menu data (products, descriptions, prices, etc.), serving as the single source of truth for menu content.</Description> <Location>/data/LiveMenu.xlsx in the repository (deployed on server but protected from public access)</Location> </Artifact> <Artifact> <Name>Generated Menu JSON</Name> <Description>JSON file output by converting LiveMenu.xlsx, used by the front-end to populate the product list dynamically.</Description> <Location>/data/menu.json in the deployed site (rebuilt on each deployment via CI)</Location> </Artifact> <Artifact> <Name>Conversion Script (Node.js)</Name> <Description>Script that reads the Excel file and outputs the JSON (uses SheetJS library). Ensures the latest Excel data is available to the frontend.</Description> <Location>convertMenu.js in repository root (executed during build in CI pipeline)</Location> </Artifact> <Artifact> <Name>Front-End Code (HTML/JS/CSS)</Name> <Description>Static frontend assets: index.html for structure, Tailwind CSS (compiled to styles.css) for design, and menu.js plus any other JS for dynamic functionality.</Description> <Location>index.html and assets/ directory in repository (served by IONOS web server)</Location> </Artifact> <Artifact> <Name>Tailwind Config</Name> <Description>Configuration and source for Tailwind CSS (to generate a customized, purged CSS file for styling the UI).</Description> <Location>tailwind.config.js and assets/tailwind.css in repository (Tailwind CLI processes these into assets/styles.css)</Location> </Artifact> <Artifact> <Name>Order Processing PHP Script</Name> <Description>Backend script (PHP) that handles form submissions: performs server-side validation, sends emails via PHPMailer, and logs orders if enabled.</Description> <Location>orderSubmit.php in repository (deployed to web root or php/ directory, accessed via form action)</Location> </Artifact> <Artifact> <Name>PHPMailer Library</Name> <Description>External PHP library for sending emails by SMTP, included via Composer. Enables authenticated email notifications for orders.</Description> <Location>vendor/phpmailer/ in deployment (installed by Composer as part of CI build, not stored in repo)</Location> </Artifact> <Artifact> <Name>CI/CD Workflow Definition</Name> <Description>Continuous integration workflow file defining automated build and deployment steps via GitHub Actions and IONOS Deploy Now.</Description> <Location>.github/workflows/ionos.yml in repository (contains Node build, Composer install, and deploy steps)</Location> </Artifact> <Artifact> <Name>IONOS Deploy Now Project (Prod)</Name> <Description>Hosting environment for the production deployment, linked to the GitHub repo. Manages building, serving the static site and PHP, domain configuration, TLS, and environment variables.</Description> <Location>IONOS Deploy Now dashboard (Project "CannabisOrderDashboardProd" with production deployment on main branch)</Location> </Artifact> <Artifact> <Name>IONOS Deploy Now Project (Staging)</Name> <Description>Hosting environment for staging deployment, linked to dev branch. Allows testing of changes in an identical environment before merging to production.</Description> <Location>IONOS Deploy Now (Staging deployment for dev branch, with preview URL provided by IONOS)</Location> </Artifact> <Artifact> <Name>Custom Domain & SSL Certificate</Name> <Description>The public domain for the dashboard and its associated TLS certificate for HTTPS. Provides a user-friendly URL and secure connection for end users.</Description> <Location>orders.examplecannabis.com (managed via IONOS; Let's Encrypt certificate auto-renewed by IONOS)</Location> </Artifact> <Artifact> <Name>Environment Configuration Template</Name> <Description>Template file for environment variables (SMTP credentials) that gets populated with secret values during deployment to configure the production runtime securely.</Description> <Location>.deploy-now/production.env.template in repository (used by Deploy Now to create .env on server)</Location> </Artifact> <Artifact> <Name>Order Log File</Name> <Description>Server-side log capturing order submissions (date/time and details) as a backup and audit trail for orders placed through the system.</Description> <Location>data/orders.log on server (not in repo; created at runtime by PHP, protected via .htaccess)</Location> </Artifact> <Artifact> <Name>Project Documentation</Name> <Description>Documents such as this deployment plan, maintenance runbook for updating menu data, and any user manuals or admin instructions compiled for the client.</Description> <Location>Project docs (shared with client via PDF or in repository docs/ folder; not part of the deployed site)</Location> </Artifact> </ArtifactsIndex> <Definitions> <Definition> <Term>Static Frontend</Term> <Meaning>A frontend delivered as fixed files (HTML/CSS/JS) without server-side page generation on each request. It can still have dynamic behavior via JavaScript in the browser (as in this project, where JSON data is fetched for dynamic content).</Meaning> </Definition> <Definition> <Term>Tailwind CSS</Term> <Meaning>A utility-first CSS framework that provides a set of classes to rapidly build custom designs. It allows responsive and modern styling directly in HTML and is optimized by purging unused styles for production.</Meaning> </Definition> <Definition> <Term>SheetJS (xlsx)</Term> <Meaning>An npm library for reading and writing Excel files in Node.js. Used here to parse LiveMenu.xlsx and convert its first sheet into JSON format for the website.</Meaning> </Definition> <Definition> <Term>PHPMailer</Term> <Meaning>A PHP library for sending emails via SMTP. Preferred over the basic mail() function because it supports authentication, encryption, and is more reliable. In this project, it sends order notification emails using configured SMTP server credentials.</Meaning> </Definition> <Definition> <Term>SMTP</Term> <Meaning>Simple Mail Transfer Protocol – the standard protocol for sending emails. We configure PHPMailer with SMTP settings (host, port, authentication) to ensure emails are sent through a designated mail server (which improves deliverability and reliability).</Meaning> </Definition> <Definition> <Term>IONOS Deploy Now</Term> <Meaning>A cloud deployment service by IONOS that connects with GitHub to automatically build and deploy projects. It supports static sites and PHP applications, provides staging environments, custom domain integration, and manages TLS certificates and environment variables.</Meaning> </Definition> <Definition> <Term>Continuous Deployment (CD)</Term> <Meaning>An approach where code changes are automatically built, tested, and deployed to production. In this project, every push to the main branch triggers an automated process that results in an updated live site on IONOS, assuming tests pass.</Meaning> </Definition> <Definition> <Term>Staging Environment</Term> <Meaning>A duplicate of the production environment used for testing changes before they go live. Our staging is an IONOS deployment from the dev branch, allowing the team and client to verify new updates in a production-like setting without affecting real users.</Meaning> </Definition> <Definition> <Term>Environment Variables (Secrets)</Term> <Meaning>Variables set outside of code (usually in the hosting environment) that hold sensitive data or config values. We use them for SMTP credentials to avoid exposing such secrets in the code repository. They are injected at runtime by the IONOS environment using our template and GitHub Secrets.</Meaning> </Definition> <Definition> <Term>Honeypot</Term> <Meaning>A spam prevention technique where an extra form field (invisible to humans) is added. Legitimate users will leave it blank, but automated bots often fill all fields. The server then detects a filled honeypot field as a sign of spam and ignores that submission.</Meaning> </Definition> <Definition> <Term>Responsive Design</Term> <Meaning>An approach to web design ensuring the user interface works well on a variety of devices (mobile, tablet, desktop). It often involves fluid layouts and CSS media queries (Tailwind facilitates this with utility classes for different breakpoints).</Meaning> </Definition> <Definition> <Term>Accessible UX (Accessibility)</Term> <Meaning>Design and development practices that make the website usable by people with disabilities. This includes semantic HTML, proper form labels, alt text for images, keyboard navigability, sufficient color contrast, etc. to conform to standards like WCAG.</Meaning> </Definition> <Definition> <Term>Work Breakdown Structure (WBS)</Term> <Meaning>A hierarchical decomposition of the project into phases, batches, and steps (tasks). This structure helps plan and manage the project by breaking it into manageable pieces with clear ownership and deliverables.</Meaning> </Definition> <Definition> <Term>RACI Matrix</Term> <Meaning>A chart that maps tasks to roles, specifying who is Responsible, Accountable, Consulted, and Informed for each task. It's a tool to clarify team responsibilities and ensure accountability.</Meaning> </Definition> <Definition> <Term>Traceability Matrix</Term> <Meaning>A table (or similar) that links requirements to the implementation (tasks/deliverables) that fulfill them. This ensures every requirement identified (e.g., from the PDF plan) is addressed and allows one to trace from requirement to solution and vice versa.</Meaning> </Definition> <Definition> <Term>Risk Register</Term> <Meaning>A list of identified project risks, including their likelihood, impact, mitigation strategies, and owners. It is actively maintained to manage potential problems proactively.</Meaning> </Definition> <Definition> <Term>Change Control</Term> <Meaning>A formal process for handling changes to the project scope or system after initial requirements are set. It involves submitting change requests, analyzing impact, getting approval, then planning and implementing the change in a controlled manner (with testing and documentation) to avoid uncontrolled scope creep or regression.</Meaning> </Definition> </Definitions> <TraceabilityMatrix> <Requirement id="R1"> <Description>Static frontend using HTML, CSS (Tailwind), and JavaScript is utilized for the user interface.</Description> <ImplementedBy> <StepRef id="2.2.1"/> <StepRef id="2.2.2"/> <StepRef id="2.2.3"/> </ImplementedBy> </Requirement> <Requirement id="R2"> <Description>An Excel file named LiveMenu.xlsx is used as the data source, stored in the /data folder of the project.</Description> <ImplementedBy> <StepRef id="1.2.1"/> <StepRef id="2.1.1"/> </ImplementedBy> </Requirement> <Requirement id="R3"> <Description>Excel-to-JSON conversion is implemented as a build step using Node.js (SheetJS/xlsx library) to produce a JSON menu file.</Description> <ImplementedBy> <StepRef id="2.1.2"/> <StepRef id="2.1.3"/> </ImplementedBy> </Requirement> <Requirement id="R4"> <Description>A backend PHP script handles order submission and sends emails via SMTP using PHPMailer.</Description> <ImplementedBy> <StepRef id="2.3.1"/> <StepRef id="2.3.2"/> </ImplementedBy> </Requirement> <Requirement id="R5"> <Description>Code and data are versioned in a GitHub repository to maintain history and enable collaboration.</Description> <ImplementedBy> <StepRef id="1.2.1"/> <StepRef id="1.2.2"/> <StepRef id="2.1.1"/> </ImplementedBy> </Requirement> <Requirement id="R6"> <Description>Continuous deployment is set up through IONOS Deploy Now integrated with GitHub for automatic deployments on each push.</Description> <ImplementedBy> <StepRef id="3.1.1"/> <StepRef id="3.1.2"/> <StepRef id="3.2.1"/> </ImplementedBy> </Requirement> <Requirement id="R7"> <Description>The site is accessible over HTTPS with TLS, provided via IONOS (auto SSL certificate provisioning).</Description> <ImplementedBy> <StepRef id="4.1.1"/> <StepRef id="4.1.2"/> </ImplementedBy> </Requirement> <Requirement id="R8"> <Description>Both client-side and server-side validation are implemented for the order form. Spam protection measures (honeypot) are in place. Secrets (SMTP credentials) are handled securely via environment variables.</Description> <ImplementedBy> <StepRef id="2.2.3"/> <StepRef id="2.3.1"/> <StepRef id="3.1.3"/> <StepRef id="2.3.2"/> </ImplementedBy> </Requirement> <Requirement id="R9"> <Description>Optional server-side logging of orders to a secure file is provided (disabled or enabled as needed for record-keeping).</Description> <ImplementedBy> <StepRef id="2.3.2"/> </ImplementedBy> </Requirement> <Requirement id="R10"> <Description>User experience is responsive (mobile-friendly) and accessible (adheres to basic accessibility guidelines).</Description> <ImplementedBy> <StepRef id="2.2.1"/> <StepRef id="5.1.2"/> <StepRef id="5.1.3"/> </ImplementedBy> </Requirement> <Requirement id="R11"> <Description>Clear processes are defined for updating the Excel file and triggering a new deployment to update the site’s menu.</Description> <ImplementedBy> <StepRef id="6.2.1"/> <StepRef id="6.2.2"/> </ImplementedBy> </Requirement> </TraceabilityMatrix> <RisksRegister> <Risk id="Risk1"> <Description>Spam or bot form submissions</Description> <Likelihood>Medium</Likelihood> <Impact>Medium</Impact> <Mitigation>Use honeypot field (implemented) and monitor submissions. If spam increases, consider adding reCAPTCHA or more robust bot checks. Set up email filters or throttling if necessary.</Mitigation> <OwnerRole>Security Engineer</OwnerRole> </Risk> <Risk id="Risk2"> <Description>Email delivery issues (order notification email not delivered or flagged as spam)</Description> <Likelihood>Low</Likelihood> <Impact>High</Impact> <Mitigation>Use authenticated SMTP with proper domain (SPF/DKIM). Test emails periodically. Monitor the mailbox spam folder initially. If needed, switch to a dedicated email service (like SendGrid) to improve deliverability.</Mitigation> <OwnerRole>Back-End Developer</OwnerRole> </Risk> <Risk id="Risk3"> <Description>Deployment pipeline failure</Description> <Likelihood>Low</Likelihood> <Impact>Medium</Impact> <Mitigation>Keep CI workflow under version control and test it with each change. If a build fails, the team is alerted via GitHub. Have a manual deployment process as backup (document how to deploy via FTP or alternate means if CI is down).</Mitigation> <OwnerRole>DevOps Engineer</OwnerRole> </Risk> <Risk id="Risk4"> <Description>Errors in Excel data format (causing conversion script to break)</Description> <Likelihood>Medium</Likelihood> <Impact>Medium</Impact> <Mitigation>Provide clear editing guidelines to Content Manager (don’t rename headers, etc.). The conversion script includes basic validation (e.g., checking expected columns). Use staging to catch any issues before hitting production. Version control allows rollback to last known good Excel if needed.</Mitigation> <OwnerRole>Content Manager</OwnerRole> </Risk> <Risk id="Risk5"> <Description>Security vulnerabilities (XSS, injection, data exposure)</Description> <Likelihood>Low</Likelihood> <Impact>High</Impact> <Mitigation>Follow secure coding practices: sanitize all inputs, escape outputs (especially if any user input were ever displayed, which currently it isn’t). Keep dependencies updated (PHPMailer etc.). Block access to sensitive files (via .htaccess, done). Conduct periodic security audits.</Mitigation> <OwnerRole>Security Engineer</OwnerRole> </Risk> <Risk id="Risk6"> <Description>High traffic or load issues</Description> <Likelihood>Low</Likelihood> <Impact>Low</Impact> <Mitigation>Static hosting can handle large traffic. Ensure images/CSS are optimized. If anticipating huge spikes (e.g., promotions), consider integrating a CDN. Monitor performance metrics; if page load times degrade, investigate (though likely front-end optimization would solve it).</Mitigation> <OwnerRole>DevOps Engineer</OwnerRole> </Risk> <Risk id="Risk7"> <Description>Accessibility or usability shortcomings</Description> <Likelihood>Medium</Likelihood> <Impact>Medium</Impact> <Mitigation>Test with assistive tools (screen readers, keyboard navigation). Address any issues (add ARIA labels, fix focus order). Take user feedback seriously (if customers find form confusing, tweak the UI). Possibly do an accessibility audit post-launch.</Mitigation> <OwnerRole>Front-End Developer</OwnerRole> </Risk> <Risk id="Risk8"> <Description>Regulatory compliance changes (e.g., new rules for online cannabis orders)</Description> <Likelihood>Low</Likelihood> <Impact>High</Impact> <Mitigation>Stay informed of relevant laws. If age verification or warnings are required, implement them promptly (could be an age gate on site or additional disclaimers). Have a plan to quickly update the site if such legal requirements emerge (this would go through change control due to high impact).</Mitigation> <OwnerRole>Business Owner</OwnerRole> </Risk> <Risk id="Risk9"> <Description>Maintenance personnel changes or knowledge loss</Description> <Likelihood>Medium</Likelihood> <Impact>Medium</Impact> <Mitigation>Keep thorough documentation (this plan, runbooks, how-to guides for updating menu, etc.). Cross-train team members (so more than one person knows how the deployment works). Store credentials securely where team can access if someone is unavailable.</Mitigation> <OwnerRole>Project Manager</OwnerRole> </Risk> </RisksRegister> <ChangeControl> <Process> <Step>Submit Change Request – Any proposed change (feature addition or significant modification) is documented. The requester (client or team member) describes the change and rationale in writing (e.g., via a change request form or GitHub issue).</Step> <Step>Impact Analysis – The technical team assesses the requested change. This includes estimating the effort, identifying affected systems or components, and evaluating potential risks or side-effects. The analysis is documented and attached to the change request.</Step> <Step>Approval – The Project Manager and Business Owner review the change request and impact analysis. They decide whether to approve, defer, or reject the change. Approval is based on value, cost, and alignment with project goals. This step assigns priority and resources if approved.</Step> <Step>Scheduling – Approved changes are scheduled into development cycles or sprints. The Project Manager updates the project timeline and any relevant planning documents. If the change alters scope significantly, a contract addendum or scope change document is prepared and signed off.</Step> <Step>Design & Development – The team designs the solution for the change (update architecture if needed) and implements it. A separate feature branch is used. This stage follows normal development practices (code reviews, unit testing, etc.). The RACI matrix is consulted/updated if new roles are involved for this change.</Step> <Step>Testing – The change is deployed to the staging environment for thorough testing. QA engineers perform regression testing to ensure existing functionality is not broken, and specific testing for the new change. The business owner or users may do UAT on staging to confirm the change meets their needs.</Step> <Step>Deployment – Upon successful testing and UAT sign-off, the change is merged to main and deployed to production via CI/CD. Coordinate the deployment timing (possibly during off-peak hours if the change might cause a brief interruption). Communicate the upcoming change to stakeholders if necessary (especially if user experience will differ).</Step> <Step>Documentation & Training – Update all relevant documents: user guides, this deployment plan (TraceabilityMatrix, ArtifactsIndex if new components), etc., to include the change. Train the client or users on the new feature if needed (even if just via a brief write-up or call explaining what’s new).</Step> <Step>Post-Implementation Review – After the change is live, monitor it closely. Gather feedback to ensure it's functioning as intended and delivering expected benefits. Document any lessons learned from the change process (for example, if something could have been smoother). Use this knowledge to refine the ChangeControl process for next time.</Step> </Process> <Guidelines>The change control process should be followed for all but trivial changes. Emergency changes (hotfixes) can be expedited (some steps done retroactively), but they should still be documented after the fact. All team members should be aware that unapproved changes are not to be deployed directly. This ensures the system remains stable and that every alteration is tracked and accountable. By adhering to these procedures, the project maintains high quality and stakeholder trust even as it evolves.</Guidelines> </ChangeControl> </Plan>
